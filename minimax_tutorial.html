<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Chess Engine: A Step-by-Step Tutorial</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            color: #34495e;
            margin-top: 40px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }

        h3 {
            color: #555;
            margin-top: 25px;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            color: #e74c3c;
        }

        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.4;
        }

        pre code {
            background-color: transparent;
            color: #ecf0f1;
            padding: 0;
        }

        .key-insight {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
        }

        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }

        .success {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
        }

        .day-marker {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .tree-diagram {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            overflow-x: auto;
        }

        .chess-board {
            background-color: #f9f9f9;
            border: 2px solid #333;
            padding: 20px;
            margin: 20px auto;
            font-family: monospace;
            text-align: center;
            max-width: 400px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #3498db;
            color: white;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .step {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .step-number {
            display: inline-block;
            background-color: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }

        .progress-bar {
            background-color: #e9ecef;
            border-radius: 10px;
            height: 30px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: width 0.3s ease;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .comparison-item h4 {
            margin-top: 0;
            color: #3498db;
        }

        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè∞ Building a Chess Engine: A Step-by-Step Tutorial</h1>

        <p><em>From zero to checkmate-finding AI: A practical, incremental approach to building your first chess engine</em></p>

        <div class="progress-bar">
            <div class="progress-fill" style="width: 100%">
                Journey Progress: Days 2-8 Complete! üéâ
            </div>
        </div>

        <h2>üìö Introduction: The Learning Journey</h2>

        <p>This tutorial documents the actual process of building a working chess engine, step by step. Rather than presenting a complete solution, we'll follow the <strong>incremental development approach</strong> that was used in this project, showing you how each component builds on the previous one.</p>

        <div class="key-insight">
            <strong>üéØ Core Philosophy:</strong> Start with the simplest thing that works, test it, understand it deeply, then add one layer of sophistication at a time. This is how real software is built, and it's the most effective way to learn.
        </div>

        <h3>What You'll Build</h3>

        <table>
            <thead>
                <tr>
                    <th>Stage</th>
                    <th>Component</th>
                    <th>Capability</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><span class="day-marker">Day 2</span></td>
                    <td>Material Evaluator</td>
                    <td>Counts pieces, makes greedy captures</td>
                </tr>
                <tr>
                    <td><span class="day-marker">Day 3-4</span></td>
                    <td>Minimax Search</td>
                    <td>Looks ahead 3-4 moves, finds tactics</td>
                </tr>
                <tr>
                    <td><span class="day-marker">Day 5</span></td>
                    <td>Positional Evaluation</td>
                    <td>Understands center control & development</td>
                </tr>
                <tr>
                    <td><span class="day-marker">Day 6</span></td>
                    <td>Strategic Evaluation</td>
                    <td>King safety, pawn structure, complete evaluator</td>
                </tr>
                <tr>
                    <td><span class="day-marker">Day 7</span></td>
                    <td>Quiescence Search</td>
                    <td>Eliminates horizon effect, tactical perfection</td>
                </tr>
                <tr>
                    <td><span class="day-marker">Day 8</span></td>
                    <td>UCI Protocol</td>
                    <td>Play in real GUIs, tournament integration</td>
                </tr>
            </tbody>
        </table>

        <h2>üéØ Day 2: Starting Simple - Material Evaluation</h2>

        <div class="day-marker">Day 2: Foundation</div>

        <p>The first rule of chess: <strong>don't lose your pieces</strong>. Before we can look ahead multiple moves or understand strategy, we need to teach our engine the basic value of pieces.</p>

        <h3>The Material Count Concept</h3>

        <p>Every chess engine starts with a simple idea: pieces have point values. The side with more material (points) is usually winning.</p>

        <div class="chess-board">
            <strong>Standard Piece Values (centipawns)</strong><br><br>
            ‚ôü Pawn = 100<br>
            ‚ôû Knight = 300<br>
            ‚ôù Bishop = 300<br>
            ‚ôú Rook = 500<br>
            ‚ôõ Queen = 900<br>
            ‚ôö King = priceless (can't be captured)
        </div>

        <div class="key-insight">
            <strong>Why centipawns?</strong> We use 100 for a pawn (instead of 1) to allow finer granularity. A small positional advantage might be worth 20 centipawns (0.2 pawns), which we couldn't represent with integers if pawns were just 1 point.
        </div>

        <h3>Implementation: evaluate_material()</h3>

        <p>Here's the actual first function built in this project:</p>

        <pre><code>def evaluate_material(board: chess.Board) -> int:
    """
    Evaluate board position based purely on material count.

    Returns:
        Score in centipawns from White's perspective:
        - Positive = White is winning
        - Negative = Black is winning
        - Zero = Material is equal
    """
    # Piece values in centipawns
    PIECE_VALUES = {
        chess.PAWN: 100,
        chess.KNIGHT: 300,
        chess.BISHOP: 300,
        chess.ROOK: 500,
        chess.QUEEN: 900,
        chess.KING: 0,  # Can't be captured
    }

    score = 0

    # Count all pieces on the board
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece is not None:
            value = PIECE_VALUES[piece.piece_type]
            if piece.color == chess.WHITE:
                score += value
            else:
                score -= value

    return score</code></pre>

        <div class="success">
            <strong>‚úÖ Test it:</strong> Starting position should return 0 (equal material). A position with White missing a queen should return -900. Simple, testable, correct.
        </div>

        <h3>Why This Isn't Enough</h3>

        <p>A material-only evaluation only looks <em>one move ahead</em>. The engine thinks: "If I make this move, do I gain material?" But it doesn't consider:</p>

        <ul>
            <li>‚ùå What will my opponent do in response?</li>
            <li>‚ùå Can I win material in 2-3 moves with a tactic?</li>
            <li>‚ùå Am I walking into a trap?</li>
        </ul>

        <p>This is where <strong>search</strong> comes in...</p>

        <h2>üîç Day 3-4: Looking Ahead - Minimax Search</h2>

        <div class="day-marker">Day 3-4: Search</div>

        <p>Now that we can evaluate a position, we need to <strong>look ahead</strong> to see what positions we'll reach. This is where minimax comes in.</p>

        <h3>The Minimax Concept</h3>

        <p>Minimax formalizes the way humans think about chess:</p>

        <div class="key-insight">
            <strong>Minimax Principle:</strong> When choosing a move, assume your opponent will play their best response. Then choose the move that gives you the best outcome even after their best reply.
        </div>

        <p>In other words:</p>
        <ul>
            <li><strong>Maximizing player (White)</strong> tries to maximize the score</li>
            <li><strong>Minimizing player (Black)</strong> tries to minimize the score</li>
            <li>Both players alternate, each assuming the other plays optimally</li>
        </ul>

        <h3>Visualizing the Game Tree</h3>

        <div class="tree-diagram">
<pre>
                    [Current Position]
                    Your turn (WHITE)
                          Eval: ?
                            |
        +-------------------+-------------------+
        |                   |                   |
    Move: e2-e4        Move: d2-d4        Move: Ng1-f3
    (explore this)     (explore this)     (explore this)
        |                   |                   |
   [After e4]          [After d4]         [After Nf3]
   Opp turn (BLACK)   Opp turn (BLACK)   Opp turn (BLACK)
        |                   |                   |
   +----+----+         +----+----+         +----+----+
   |    |    |         |    |    |         |    |    |
  e7e5 d7d5 Ng8f6    e7e5 d7d5 ...      e7e5 d7d5 ...

White searches each possibility, assumes Black responds optimally,
then picks the move with the best guaranteed outcome.
</pre>
        </div>

        <h3>The Algorithm</h3>

        <div class="step">
            <span class="step-number">1</span>
            <strong>Generate moves</strong> - Get all legal moves from current position
        </div>

        <div class="step">
            <span class="step-number">2</span>
            <strong>Recurse</strong> - For each move, explore the resulting position to a certain depth
        </div>

        <div class="step">
            <span class="step-number">3</span>
            <strong>Evaluate leaves</strong> - At maximum depth, use evaluate_material() to score the position
        </div>

        <div class="step">
            <span class="step-number">4</span>
            <strong>Propagate values</strong> - Work backwards: MAX nodes take maximum child value, MIN nodes take minimum
        </div>

        <div class="step">
            <span class="step-number">5</span>
            <strong>Choose best</strong> - At root, select the move leading to the best score
        </div>

        <h3>Implementation: minimax() with Alpha-Beta Pruning</h3>

        <p>Here's the actual minimax implementation from this project. It includes <strong>alpha-beta pruning</strong>, an optimization that skips branches that can't affect the final decision:</p>

        <pre><code>def minimax(board: chess.Board, depth: int, alpha: float, beta: float,
            maximizing: bool) -> float:
    """
    Minimax search with alpha-beta pruning.

    Args:
        board: Current chess position
        depth: How many more plies (half-moves) to search
        alpha: Best score White can guarantee (lower bound)
        beta: Best score Black can guarantee (upper bound)
        maximizing: True if White's turn, False if Black's turn

    Returns:
        Best evaluation score from this position
    """
    # Base case: reached depth limit or game over
    if depth == 0 or board.is_game_over():
        return evaluate(board)  # Use our evaluation function

    legal_moves = list(board.legal_moves)

    # Order moves for better pruning (captures first, then checks)
    ordered_moves = order_moves(board, legal_moves)

    if maximizing:
        # White's turn: maximize score
        max_eval = float('-inf')
        for move in ordered_moves:
            board.push(move)
            eval_score = minimax(board, depth - 1, alpha, beta, False)
            board.pop()

            max_eval = max(max_eval, eval_score)
            alpha = max(alpha, eval_score)

            # Beta cutoff: Black won't allow this branch
            if beta <= alpha:
                break  # Prune remaining moves

        return max_eval
    else:
        # Black's turn: minimize score
        min_eval = float('inf')
        for move in ordered_moves:
            board.push(move)
            eval_score = minimax(board, depth - 1, alpha, beta, True)
            board.pop()

            min_eval = min(min_eval, eval_score)
            beta = min(beta, eval_score)

            # Alpha cutoff: White won't allow this branch
            if beta <= alpha:
                break  # Prune remaining moves

        return min_eval</code></pre>

        <h3>Alpha-Beta Pruning: The Secret Sauce</h3>

        <div class="key-insight">
            <strong>Alpha-Beta Insight:</strong> If you're exploring a move and discover it leads to a position worse than what you've already found, you can stop exploring that branch immediately. The opponent would never let you reach it anyway.
        </div>

        <div class="comparison">
            <div class="comparison-item">
                <h4>Without Pruning</h4>
                <p>Must explore every possible path to given depth</p>
                <p><strong>Nodes:</strong> ~1.5 million at depth 4</p>
                <p><strong>Time:</strong> ~2-3 seconds</p>
            </div>
            <div class="comparison-item">
                <h4>With Alpha-Beta</h4>
                <p>Skips branches that can't improve the result</p>
                <p><strong>Nodes:</strong> ~40,000 at depth 4 (good move ordering)</p>
                <p><strong>Time:</strong> ~0.1 seconds</p>
            </div>
        </div>

        <h3>Move Ordering: Making Pruning More Effective</h3>

        <p>The order you search moves matters enormously. If you search the best move first, alpha-beta prunes more branches:</p>

        <pre><code>def order_moves(board: chess.Board, moves: list) -> list:
    """
    Order moves for efficient alpha-beta pruning.
    Search likely-good moves first:
    1. Captures (especially winning captures)
    2. Checks
    3. Other moves
    """
    def move_priority(move):
        score = 0

        # Captures get high priority (MVV-LVA heuristic)
        if board.is_capture(move):
            captured = board.piece_at(move.to_square)
            if captured:
                score += captured.piece_type * 100  # Victim value
            attacker = board.piece_at(move.from_square)
            if attacker:
                score -= attacker.piece_type  # Use less valuable attacker

        # Checks get medium priority
        board_copy = board.copy()
        board_copy.push(move)
        if board_copy.is_check():
            score += 50

        # Promotions get very high priority
        if move.promotion:
            score += 900

        return score

    return sorted(moves, key=move_priority, reverse=True)</code></pre>

        <div class="success">
            <strong>‚úÖ Result:</strong> With just material evaluation + minimax + alpha-beta + move ordering, you now have an engine that can find checkmates in 2-3 moves and avoid simple tactical blunders. It's playing at a beginner-intermediate level!
        </div>

        <h3>What's Still Missing</h3>

        <p>Our engine can now <em>search</em>, but it still only understands <em>material</em>. It doesn't know:</p>
        <ul>
            <li>‚ùå Center control is important</li>
            <li>‚ùå Developed pieces are better than undeveloped ones</li>
            <li>‚ùå King safety matters</li>
            <li>‚ùå Pawn structure affects the position</li>
        </ul>

        <p>Time to teach it <strong>positional understanding</strong>...</p>

        <h2>‚ôüÔ∏è Day 5: Positional Understanding</h2>

        <div class="day-marker">Day 5: Position</div>

        <p>Now that our engine can search effectively, let's teach it the <em>principles</em> of good chess. We'll add two fundamental concepts: center control and piece development.</p>

        <h3>Center Control</h3>

        <p>The four central squares (d4, e4, d5, e5) are the most important in chess. Controlling the center gives your pieces more mobility and restricts your opponent.</p>

        <div class="chess-board">
<pre>
   a  b  c  d  e  f  g  h
8  .  .  .  .  .  .  .  .  8
7  .  .  .  .  .  .  .  .  7
6  .  .  .  X  X  .  .  .  6  ‚Üê Extended Center
5  .  .  .  ‚òÖ  ‚òÖ  .  .  .  5  ‚Üê Main Center
4  .  .  .  ‚òÖ  ‚òÖ  .  .  .  4  ‚Üê Main Center
3  .  .  .  X  X  .  .  .  3  ‚Üê Extended Center
2  .  .  .  .  .  .  .  .  2
1  .  .  .  .  .  .  .  .  1
   a  b  c  d  e  f  g  h

   ‚òÖ = Center squares (most important)
   X = Extended center (also valuable)
</pre>
        </div>

        <h3>Implementation: evaluate_center_control()</h3>

        <pre><code>def evaluate_center_control(board: chess.Board) -> int:
    """
    Evaluate center control.
    Pieces occupying center squares get bonuses.
    """
    CENTER_SQUARES = [chess.D4, chess.E4, chess.D5, chess.E5]
    EXTENDED_CENTER = [
        chess.C3, chess.D3, chess.E3, chess.F3,
        chess.C4, chess.D4, chess.E4, chess.F4,
        chess.C5, chess.D5, chess.E5, chess.F5,
        chess.C6, chess.D6, chess.E6, chess.F6,
    ]

    score = 0

    # Bonus for pieces in the center
    for square in CENTER_SQUARES:
        piece = board.piece_at(square)
        if piece:
            if piece.piece_type == chess.PAWN:
                bonus = 30  # Pawns in center are very strong
            elif piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                bonus = 20  # Centralized minor pieces
            else:
                bonus = 10  # Other pieces

            if piece.color == chess.WHITE:
                score += bonus
            else:
                score -= bonus

    # Smaller bonus for extended center (similar logic...)
    # [Code continues for extended center]

    return score</code></pre>

        <h3>Piece Development</h3>

        <p>In the opening, you want to get your knights and bishops off their starting squares. Keeping pieces on the back rank is inefficient.</p>

        <h3>Implementation: evaluate_piece_development()</h3>

        <pre><code>def evaluate_piece_development(board: chess.Board) -> int:
    """
    Evaluate piece development.
    Penalizes knights and bishops still on starting squares.
    """
    WHITE_KNIGHT_START = [chess.B1, chess.G1]
    BLACK_KNIGHT_START = [chess.B8, chess.G8]
    WHITE_BISHOP_START = [chess.C1, chess.F1]
    BLACK_BISHOP_START = [chess.C8, chess.F8]

    score = 0

    # Only apply in early game (first 10 moves)
    if board.fullmove_number <= 10:
        # Penalize undeveloped knights
        for square in WHITE_KNIGHT_START:
            piece = board.piece_at(square)
            if piece and piece.piece_type == chess.KNIGHT:
                score -= 15  # Penalty for undeveloped knight

        for square in BLACK_KNIGHT_START:
            piece = board.piece_at(square)
            if piece and piece.piece_type == chess.KNIGHT:
                score += 15  # Penalty for Black

        # Similar for bishops (10 point penalty each)
        # [Code continues for bishops]

    return score</code></pre>

        <div class="key-insight">
            <strong>üéØ Incremental Testing:</strong> After adding these functions, test them individually! Verify that a position with a knight on d4 scores higher than one with the knight on g1. Build confidence in each component before combining them.
        </div>

        <h2>üè∞ Day 6: Strategic Understanding</h2>

        <div class="day-marker">Day 6: Strategy</div>

        <p>The final step: teaching our engine about king safety and pawn structure. These concepts separate weak engines from strong ones.</p>

        <h3>King Safety</h3>

        <p>An exposed king is dangerous, especially in the opening and middlegame. We reward:</p>
        <ul>
            <li>‚úÖ Castling (getting the king to safety)</li>
            <li>‚úÖ Pawn shield in front of the castled king</li>
            <li>‚ùå Penalize kings in the center</li>
        </ul>

        <h3>Implementation: evaluate_king_safety()</h3>

        <pre><code>def evaluate_king_safety(board: chess.Board) -> int:
    """
    Evaluate king safety.
    Rewards castling and pawn shields, penalizes exposed kings.
    """
    score = 0

    # Bonus for castling rights (potential to castle)
    if board.has_kingside_castling_rights(chess.WHITE):
        score += 10
    if board.has_kingside_castling_rights(chess.BLACK):
        score -= 10

    # Check if kings have castled (heuristic: king on g1/g8 or c1/c8)
    white_king_square = board.king(chess.WHITE)
    black_king_square = board.king(chess.BLACK)

    # White king castled kingside
    if white_king_square == chess.G1:
        score += 30  # Castling bonus

        # Check for pawn shield (pawns on f2, g2, h2)
        if board.piece_at(chess.F2) == chess.Piece(chess.PAWN, chess.WHITE):
            score += 10
        if board.piece_at(chess.G2) == chess.Piece(chess.PAWN, chess.WHITE):
            score += 10
        if board.piece_at(chess.H2) == chess.Piece(chess.PAWN, chess.WHITE):
            score += 10

    # Penalty for king in center (dangerous!)
    if white_king_square in CENTER_SQUARES:
        score -= 40

    # [Similar logic for Black king...]

    return score</code></pre>

        <h3>Pawn Structure</h3>

        <p>Pawns can't move backwards, so their structure is permanent. We evaluate:</p>

        <table>
            <thead>
                <tr>
                    <th>Pattern</th>
                    <th>Description</th>
                    <th>Evaluation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Doubled Pawns</td>
                    <td>Two pawns on the same file</td>
                    <td>‚ùå -20 centipawns (weak)</td>
                </tr>
                <tr>
                    <td>Isolated Pawn</td>
                    <td>No friendly pawns on adjacent files</td>
                    <td>‚ùå -15 centipawns (hard to defend)</td>
                </tr>
                <tr>
                    <td>Passed Pawn</td>
                    <td>No enemy pawns blocking path to promotion</td>
                    <td>‚úÖ +20 to +90 centipawns (very strong!)</td>
                </tr>
            </tbody>
        </table>

        <h3>Implementation: evaluate_pawn_structure()</h3>

        <pre><code>def evaluate_pawn_structure(board: chess.Board) -> int:
    """
    Evaluate pawn structure.
    Penalizes doubled/isolated pawns, rewards passed pawns.
    """
    score = 0

    # Analyze each file (a-h)
    for file in range(8):
        white_pawns_on_file = []
        black_pawns_on_file = []

        # Find all pawns on this file
        for rank in range(8):
            square = chess.square(file, rank)
            piece = board.piece_at(square)
            if piece and piece.piece_type == chess.PAWN:
                if piece.color == chess.WHITE:
                    white_pawns_on_file.append(rank)
                else:
                    black_pawns_on_file.append(rank)

        # Doubled pawns penalty (2 pawns = -20, 3 pawns = -40, etc.)
        if len(white_pawns_on_file) > 1:
            score -= 20 * (len(white_pawns_on_file) - 1)
        if len(black_pawns_on_file) > 1:
            score += 20 * (len(black_pawns_on_file) - 1)

        # Isolated pawns (check if no friendly pawns on adjacent files)
        # [Code continues...]

        # Passed pawns bonus (no enemy pawns blocking)
        for white_rank in white_pawns_on_file:
            is_passed = True
            # Check if any black pawns ahead on same or adjacent files
            # [Code continues...]
            if is_passed:
                # Bonus increases as pawn advances
                score += 20 + (white_rank * 10)

    return score</code></pre>

        <h2>üéº Putting It All Together: The Complete Evaluation</h2>

        <p>Now we combine all our evaluation components into one master function. This is the function that minimax calls at leaf nodes:</p>

        <pre><code>def evaluate(board: chess.Board) -> int:
    """
    Main evaluation function - combines all components.

    Returns score in centipawns from White's perspective.
    """
    # Check for game over first
    if board.is_checkmate():
        if board.turn == chess.WHITE:
            return -100000  # White is checkmated (Black wins)
        else:
            return 100000   # Black is checkmated (White wins)

    if board.is_stalemate() or board.is_insufficient_material():
        return 0  # Draw

    # Start with material (most important - ~80% of evaluation)
    score = evaluate_material(board)

    # Add positional components (each ~10-50 centipawns typically)
    score += evaluate_center_control(board)
    score += evaluate_piece_development(board)
    score += evaluate_king_safety(board)
    score += evaluate_pawn_structure(board)

    # Small bonus for giving check
    if board.is_check():
        if board.turn == chess.WHITE:
            score -= 50  # Black gave check
        else:
            score += 50  # White gave check

    # Tiny mobility bonus (encourages active play)
    mobility = board.legal_moves.count()
    if board.turn == chess.WHITE:
        score += mobility
    else:
        score -= mobility

    return score</code></pre>

        <div class="key-insight">
            <strong>üéØ Evaluation Hierarchy:</strong> Notice how material dominates (a pawn = 100 points) while positional factors add 10-50 points. This is intentional! Material is most important, but when material is equal, positional factors decide the game.
        </div>

        <h2>üéÆ Testing Your Engine</h2>

        <p>Now that you have a complete engine, test it on positions with known solutions:</p>

        <h3>Test 1: Mate in 1</h3>
        <pre><code># Back rank mate
board = chess.Board("6k1/5ppp/8/8/8/8/5PPP/4R1K1 w - - 0 1")
move = best_move_minimax(board, depth=2)
# Should find Re8# (checkmate)
print(f"Engine plays: {move}")  # Should be e1e8</code></pre>

        <h3>Test 2: Winning a Piece</h3>
        <pre><code># Hanging queen
board = chess.Board("rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPPQPPP/RNB1KBNR b KQkq - 0 1")
move = best_move_minimax(board, depth=3)
# Should capture the queen on e2
print(f"Engine plays: {move}")  # Should capture queen</code></pre>

        <h3>Test 3: Positional Play</h3>
        <pre><code># Starting position - should develop pieces, control center
board = chess.Board()
move = best_move_minimax(board, depth=3)
# Should play e4, d4, Nf3, or similar developing move
print(f"Engine plays: {move}")</code></pre>

        <div class="success">
            <strong>‚úÖ Congratulations!</strong> You now have a working chess engine that can:
            <ul>
                <li>Find checkmates in 2-3 moves</li>
                <li>Avoid tactical blunders</li>
                <li>Develop pieces sensibly in the opening</li>
                <li>Understand basic strategy (center, king safety, pawn structure)</li>
            </ul>
            This engine can beat most casual players and play at an intermediate level!
        </div>

        <h2>üî≠ Day 7: Quiescence Search - Fixing the Horizon Effect</h2>

        <div class="day-marker">Day 7: Tactical Perfection</div>

        <p>Your engine can now search, evaluate positions, and play decent chess. But there's a critical bug lurking in the search algorithm‚Äîone that causes devastating tactical blunders. Let's find it and fix it.</p>

        <h3>The Problem: The Horizon Effect</h3>

        <p>Run your engine on this position and watch it blunder:</p>

        <div class="chess-board">
<pre>
   a  b  c  d  e  f  g  h
8  r  .  .  q  k  .  .  r  8
7  p  p  p  .  .  p  p  p  7
6  .  .  n  .  .  n  .  .  6
5  .  .  .  p  B  .  .  .  5  ‚Üê Bishop can capture pawn
4  .  .  .  .  P  .  .  .  4
3  .  .  .  .  .  N  .  .  3
2  P  P  P  .  .  P  P  P  2
1  R  .  .  Q  K  .  .  R  1
   a  b  c  d  e  f  g  h

White to move (depth 3)
</pre>
        </div>

        <p>The engine sees <code>Bxe5</code> and evaluates it as winning a pawn (+100 centipawns). It searches to depth 3:</p>

        <div class="tree-diagram">
<pre>
Depth 1: Bxe5 (White captures pawn)
         Evaluation at depth 3: Material +100 ‚úÖ Looks good!

Depth 2: ...any Black move (engine doesn't see the problem)
Depth 3: White's response
         ‚õî SEARCH STOPS HERE

Depth 4: ...Nxe5 (Black recaptures the bishop!)
         üí• ACTUAL evaluation: Material -200 (lost bishop for pawn!)
</pre>
        </div>

        <div class="warning">
            <strong>‚ö†Ô∏è The Horizon Effect:</strong> The engine stops searching at depth 3, right before a critical tactical blow. It's like looking at a cliff but stopping your gaze 3 feet before the edge‚Äîyou think you're safe, but one more step is disaster!
        </div>

        <p>This happens because:</p>
        <ul>
            <li>‚ùå Fixed-depth search stops in the middle of tactical sequences</li>
            <li>‚ùå Position looks good at depth N, but tactical blow comes at depth N+1</li>
            <li>‚ùå Engine "pushes" problems past the horizon, thinking it avoided them</li>
        </ul>

        <h3>Real-World Example</h3>

        <p>Before quiescence search, our engine made blunders like this in real games:</p>

        <table>
            <thead>
                <tr>
                    <th>Move</th>
                    <th>Engine Thought</th>
                    <th>Reality</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Bxe5</td>
                    <td>"I win a pawn! +100"</td>
                    <td>Bishop gets recaptured (-200)</td>
                </tr>
                <tr>
                    <td>Qxc6</td>
                    <td>"I win a knight! +300"</td>
                    <td>Queen gets trapped (-900)</td>
                </tr>
                <tr>
                    <td>Rxf7</td>
                    <td>"I win a pawn! +100"</td>
                    <td>Rook hangs to king (-500)</td>
                </tr>
            </tbody>
        </table>

        <h3>The Solution: Quiescence Search</h3>

        <p>The fix is elegant: <strong>don't stop searching when the position is "noisy" (full of tactics)</strong>. Keep searching tactical moves until the position becomes "quiet."</p>

        <div class="key-insight">
            <strong>üéØ Quiescence Principle:</strong> At maximum search depth, instead of evaluating immediately, continue searching only "noisy" moves (captures, checks, promotions) until no more immediate tactics remain. Only evaluate when the position is quiet.
        </div>

        <h3>What Makes a Position "Quiet"?</h3>

        <div class="comparison">
            <div class="comparison-item">
                <h4>Noisy Position üîä</h4>
                <p><strong>Keep searching:</strong></p>
                <ul>
                    <li>‚úÖ Captures available</li>
                    <li>‚úÖ Checks available</li>
                    <li>‚úÖ Promotions available</li>
                    <li>‚úÖ Hanging pieces</li>
                </ul>
                <p><em>Danger: Tactics are happening!</em></p>
            </div>
            <div class="comparison-item">
                <h4>Quiet Position üîá</h4>
                <p><strong>Safe to evaluate:</strong></p>
                <ul>
                    <li>‚ùå No captures worth taking</li>
                    <li>‚ùå No checks available</li>
                    <li>‚ùå No promotions</li>
                    <li>‚úÖ Position is stable</li>
                </ul>
                <p><em>Safe: No immediate tactics</em></p>
            </div>
        </div>

        <h3>Implementation: quiescence_search()</h3>

        <p>Here's the actual quiescence function added to the project:</p>

        <pre><code>def quiescence_search(board: chess.Board, alpha: float, beta: float,
                      maximizing: bool, max_depth: int = 10) -> float:
    """
    Quiescence search - searches only tactical moves until position is quiet.

    Prevents the horizon effect by continuing search beyond normal depth
    for captures, checks, and promotions.

    Args:
        board: Current position
        alpha: Best score White can guarantee
        beta: Best score Black can guarantee
        maximizing: True if White's turn
        max_depth: Safety limit to prevent infinite loops

    Returns:
        Evaluation score of the quiet position
    """
    # Check for game over
    if board.is_game_over():
        return evaluate(board)

    # Stand-pat score: evaluation if we make no more captures
    # This represents "doing nothing" - if position is already good, we can stop
    stand_pat = evaluate(board)

    # Safety limit to prevent infinite search
    if max_depth <= 0:
        return stand_pat

    # Beta cutoff: If stand-pat score is already too good, opponent won't allow it
    if maximizing:
        if stand_pat >= beta:
            return beta  # Opponent won't let us reach this position
        if stand_pat > alpha:
            alpha = stand_pat  # Update lower bound
    else:
        if stand_pat <= alpha:
            return alpha  # We won't let opponent reach this
        if stand_pat < beta:
            beta = stand_pat  # Update upper bound

    # Generate only "noisy" moves: captures, checks, promotions
    all_moves = list(board.legal_moves)
    noisy_moves = []

    for move in all_moves:
        # Include captures
        if board.is_capture(move):
            noisy_moves.append(move)
            continue

        # Include promotions
        if move.promotion:
            noisy_moves.append(move)
            continue

        # Include checks (but be selective - can make search slow)
        if len(noisy_moves) < 5:  # Only if not many captures
            board.push(move)
            if board.is_check():
                noisy_moves.append(move)
            board.pop()

    # If no noisy moves, position is quiet - return stand-pat evaluation
    if not noisy_moves:
        return stand_pat

    # Order noisy moves (best captures first)
    ordered_moves = order_moves(board, noisy_moves)

    # Search noisy moves recursively
    if maximizing:
        for move in ordered_moves:
            board.push(move)
            score = quiescence_search(board, alpha, beta, False, max_depth - 1)
            board.pop()

            if score >= beta:
                return beta  # Beta cutoff
            if score > alpha:
                alpha = score
        return alpha
    else:
        for move in ordered_moves:
            board.push(move)
            score = quiescence_search(board, alpha, beta, True, max_depth - 1)
            board.pop()

            if score <= alpha:
                return alpha  # Alpha cutoff
            if score < beta:
                beta = score
        return beta</code></pre>

        <h3>The Stand-Pat Concept</h3>

        <p>One key innovation in quiescence search is the <strong>stand-pat score</strong>:</p>

        <div class="key-insight">
            <strong>Stand-Pat:</strong> The evaluation of the current position if we choose to make no more tactical moves. It represents "doing nothing" and accepting the current position.
        </div>

        <p>Why is this important?</p>

        <div class="step">
            <span class="step-number">1</span>
            <strong>Not all captures are good</strong> - Just because a capture exists doesn't mean you should take it
        </div>

        <div class="step">
            <span class="step-number">2</span>
            <strong>Option to stop</strong> - If the position is already winning, you don't need to capture
        </div>

        <div class="step">
            <span class="step-number">3</span>
            <strong>Prevents forced bad tactics</strong> - Engine isn't forced to make captures that worsen position
        </div>

        <p>Example: You're up a queen. There's a capture available (pawn takes pawn), but it's defended. Stand-pat lets you say "I'm already winning, I don't need this risky capture."</p>

        <h3>Integrating with Minimax</h3>

        <p>The integration is simple‚Äîjust one line change in the minimax function:</p>

        <pre><code>def minimax(board: chess.Board, depth: int, alpha: float, beta: float,
            maximizing: bool) -> float:
    # ... (game over checks)

    # OLD VERSION - Base case at depth 0:
    # if depth == 0:
    #     return evaluate(board)  # ‚ùå Stops in middle of tactics!

    # NEW VERSION - Use quiescence search at depth 0:
    if depth == 0:
        return quiescence_search(board, alpha, beta, maximizing)  # ‚úÖ Searches to quiet position!

    # ... (rest of minimax unchanged)</code></pre>

        <div class="success">
            <strong>‚úÖ That's it!</strong> One line change transforms your engine from tactically weak to tactically sound. This is the power of elegant algorithms.
        </div>

        <h3>Performance Impact</h3>

        <p>You might worry: "Won't searching extra moves make the engine much slower?" Let's look at the actual data:</p>

        <table>
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Before Quiescence</th>
                    <th>After Quiescence</th>
                    <th>Change</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Nodes searched</td>
                    <td>1,292</td>
                    <td>2,470</td>
                    <td>+91%</td>
                </tr>
                <tr>
                    <td>Time per move</td>
                    <td>0.47s</td>
                    <td>0.59s</td>
                    <td>+25%</td>
                </tr>
                <tr>
                    <td>Nodes per second</td>
                    <td>2,757</td>
                    <td>4,211</td>
                    <td>+53%</td>
                </tr>
                <tr>
                    <td>Tactical blunders</td>
                    <td>Frequent</td>
                    <td>Eliminated</td>
                    <td>‚úÖ Fixed!</td>
                </tr>
            </tbody>
        </table>

        <div class="key-insight">
            <strong>üìä Analysis:</strong> We search almost 2x more nodes (+91%), but only take 25% more time. Why? Because quiescence nodes are cheap‚Äîthey only search captures, not all moves. The engine is also 53% more efficient per node!
        </div>

        <h3>Before & After: Tournament Results</h3>

        <p>Here's the dramatic impact on actual game results:</p>

        <h4>Before Quiescence Search</h4>
        <table>
            <thead>
                <tr>
                    <th>Opponent</th>
                    <th>Score</th>
                    <th>Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Random Player</td>
                    <td>10-0 (100%)</td>
                    <td>Easy wins</td>
                </tr>
                <tr>
                    <td>Material-Only</td>
                    <td>10-0 (100%)</td>
                    <td>Dominated</td>
                </tr>
                <tr>
                    <td>Depth-2 Minimax</td>
                    <td>10-0 (100%)</td>
                    <td>Tactical blunders on both sides</td>
                </tr>
            </tbody>
        </table>

        <h4>After Quiescence Search</h4>
        <table>
            <thead>
                <tr>
                    <th>Opponent</th>
                    <th>Score</th>
                    <th>Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Random Player</td>
                    <td>10-0 (100%)</td>
                    <td>Still perfect, cleaner wins</td>
                </tr>
                <tr>
                    <td>Material-Only</td>
                    <td>9-0-1 (95%)</td>
                    <td>One draw by repetition (more careful!)</td>
                </tr>
                <tr>
                    <td>Tactical Puzzles</td>
                    <td>3/3 (100%)</td>
                    <td>No more horizon effect blunders!</td>
                </tr>
            </tbody>
        </table>

        <div class="warning">
            <strong>ü§î Interesting observation:</strong> We got our first draw against Material-Only! Is this bad? No! The draw was by threefold repetition, which shows the engine is now more careful about captures. It won't force risky tactics when the position is unclear‚Äîthat's actually better chess!
        </div>

        <h3>Testing Quiescence Search</h3>

        <p>Create a simple test to verify quiescence works:</p>

        <pre><code># Test: Capture with recapture (should avoid bad capture)
board = chess.Board("rnbqkbnr/pppp1ppp/8/4p3/2B1P3/8/PPPP1PPP/RNBQK1NR w KQkq - 0 1")
# Bishop on c4 can take e5 pawn, but it's defended by the d6 pawn

move = best_move_minimax(board, depth=3)

# WITHOUT quiescence: Might play Bxe5 (thinks it wins a pawn)
# WITH quiescence: Avoids Bxe5 (sees ...dxe5 recapture)

print(f"Engine plays: {move}")
# Should NOT be Bxe5 if quiescence is working</code></pre>

        <div class="success">
            <strong>‚úÖ Validation:</strong> With quiescence search, the engine now:
            <ul>
                <li>Sees full capture sequences (no more hanging pieces)</li>
                <li>Finds forced checkmates more reliably</li>
                <li>Evaluates tactical positions correctly</li>
                <li>Plays at an estimated <strong>1300-1400 Elo</strong> level (up from 1200)</li>
            </ul>
        </div>

        <h3>Why This Matters: Estimated Elo Gain</h3>

        <p>Quiescence search is one of the most important improvements you can make to a chess engine:</p>

        <div class="comparison">
            <div class="comparison-item">
                <h4>Before Quiescence</h4>
                <p><strong>~1200 Elo</strong></p>
                <ul>
                    <li>Finds tactics sometimes</li>
                    <li>Makes horizon effect blunders</li>
                    <li>Loses pieces unexpectedly</li>
                    <li>Beginner-intermediate level</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>After Quiescence</h4>
                <p><strong>~1300-1400 Elo</strong></p>
                <ul>
                    <li>Finds tactics reliably</li>
                    <li>No horizon effect blunders</li>
                    <li>Accurate tactical evaluation</li>
                    <li>Solid intermediate level</li>
                </ul>
            </div>
        </div>

        <div class="key-insight">
            <strong>üí° Expected Elo Gain:</strong> +100 to +200 Elo. This is considered one of the highest-value improvements in classical chess engine development!
        </div>

        <h2>‚ôüÔ∏è Day 8: UCI Protocol - Making Your Engine Talk to the World</h2>

        <div class="day-marker">Day 8: Integration</div>

        <p>You've built a powerful chess engine with search, evaluation, and tactics. But right now, it only exists as Python code. What if you could play against it in a real chess GUI like Arena or Cute Chess? What if you could watch it play against other engines?</p>

        <p>That's where <strong>UCI (Universal Chess Interface)</strong> comes in. It's the standard protocol that lets any chess engine communicate with any chess GUI.</p>

        <h3>What is UCI?</h3>

        <p>UCI is a simple text-based protocol developed in 2000 for Shredder and later adopted industry-wide. It defines how chess GUIs and engines communicate:</p>

        <div class="key-insight">
            <strong>UCI Principle:</strong> The GUI sends text commands to the engine via stdin (like "position startpos" or "go depth 3"), and the engine responds via stdout (like "bestmove e2e4"). Simple text in, text out.
        </div>

        <div class="comparison">
            <div class="comparison-item">
                <h4>Without UCI üò¢</h4>
                <ul>
                    <li>‚ùå Can only test via Python scripts</li>
                    <li>‚ùå Can't play against visually</li>
                    <li>‚ùå No standard GUI integration</li>
                    <li>‚ùå Hard to analyze games</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>With UCI üéâ</h4>
                <ul>
                    <li>‚úÖ Load in Arena, Cute Chess, PyChess</li>
                    <li>‚úÖ Play against your engine visually</li>
                    <li>‚úÖ Run tournaments automatically</li>
                    <li>‚úÖ Analyze games with PGN output</li>
                </ul>
            </div>
        </div>

        <h3>The UCI Protocol Flow</h3>

        <p>Here's a typical conversation between a GUI and your engine:</p>

        <div class="tree-diagram">
<pre>
GUI ‚Üí Engine: uci
Engine ‚Üí GUI: id name Chess_RL v0.1.0
              id author Your Name
              option name Search Depth type spin default 3 min 1 max 6
              uciok

GUI ‚Üí Engine: isready
Engine ‚Üí GUI: readyok

GUI ‚Üí Engine: ucinewgame
GUI ‚Üí Engine: position startpos
GUI ‚Üí Engine: go depth 3
Engine ‚Üí GUI: info depth 3 score cp 20
              bestmove e2e4

(User makes move e7e5)

GUI ‚Üí Engine: position startpos moves e2e4 e7e5
GUI ‚Üí Engine: go depth 3
Engine ‚Üí GUI: info depth 3 score cp 15
              bestmove g1f3
</pre>
        </div>

        <h3>Essential UCI Commands</h3>

        <p>Your engine needs to implement these core commands:</p>

        <table>
            <thead>
                <tr>
                    <th>Command</th>
                    <th>Purpose</th>
                    <th>Response</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>uci</code></td>
                    <td>Identify the engine</td>
                    <td><code>id name ...<br>uciok</code></td>
                </tr>
                <tr>
                    <td><code>isready</code></td>
                    <td>Check if engine is ready</td>
                    <td><code>readyok</code></td>
                </tr>
                <tr>
                    <td><code>ucinewgame</code></td>
                    <td>Prepare for new game</td>
                    <td>(no response)</td>
                </tr>
                <tr>
                    <td><code>position</code></td>
                    <td>Set board position</td>
                    <td>(no response)</td>
                </tr>
                <tr>
                    <td><code>go</code></td>
                    <td>Calculate best move</td>
                    <td><code>bestmove e2e4</code></td>
                </tr>
                <tr>
                    <td><code>quit</code></td>
                    <td>Shutdown engine</td>
                    <td>(exit program)</td>
                </tr>
            </tbody>
        </table>

        <h3>Implementation: UCIEngine Class</h3>

        <p>Here's the core structure of a UCI engine. We'll build it step by step:</p>

        <pre><code>class UCIEngine:
    """UCI-compliant chess engine wrapper."""

    def __init__(self):
        self.board = chess.Board()
        self.engine_type = "minimax"  # default
        self.search_depth = 3
        self.debug = False

    def handle_uci(self):
        """Identify the engine and declare options."""
        print("id name Chess_RL v0.1.0")
        print("id author Your Name")
        print()

        # Declare configurable options
        print("option name Engine Type type combo default minimax var random var material var minimax")
        print("option name Search Depth type spin default 3 min 1 max 6")
        print("option name Debug type check default false")
        print()

        print("uciok", flush=True)

    def handle_isready(self):
        """Confirm engine is ready."""
        print("readyok", flush=True)

    def handle_position(self, args: list):
        """Set up the board position."""
        if args[0] == "startpos":
            self.board = chess.Board()
            idx = 1
        elif args[0] == "fen":
            # Parse FEN string
            fen_parts = []
            idx = 1
            while idx < len(args) and args[idx] != "moves":
                fen_parts.append(args[idx])
                idx += 1
            self.board = chess.Board(" ".join(fen_parts))

        # Apply moves if present
        if idx < len(args) and args[idx] == "moves":
            idx += 1
            for move_str in args[idx:]:
                move = chess.Move.from_uci(move_str)
                self.board.push(move)

    def handle_go(self, args: list):
        """Calculate and return best move."""
        # Parse search depth if specified
        search_depth = self.search_depth
        if "depth" in args:
            depth_idx = args.index("depth")
            search_depth = int(args[depth_idx + 1])

        # Get best move using your engine
        if self.engine_type == "minimax":
            best_move = best_move_minimax(self.board, search_depth)
        elif self.engine_type == "material":
            best_move = best_move_material(self.board)
        else:
            best_move = random.choice(list(self.board.legal_moves))

        # Send info and best move
        score = evaluate(self.board)
        print(f"info depth {search_depth} score cp {score}", flush=True)
        print(f"bestmove {best_move.uci()}", flush=True)

    def run(self):
        """Main UCI loop - read stdin, respond to stdout."""
        while True:
            line = input().strip()
            if not line:
                continue

            parts = line.split()
            command = parts[0]
            args = parts[1:]

            if command == "uci":
                self.handle_uci()
            elif command == "isready":
                self.handle_isready()
            elif command == "position":
                self.handle_position(args)
            elif command == "go":
                self.handle_go(args)
            elif command == "quit":
                sys.exit(0)
            # ... handle other commands</code></pre>

        <div class="key-insight">
            <strong>üéØ Key Design:</strong> UCI is just a thin wrapper around your existing engine! All the hard work (search, evaluation) is already done. UCI just translates text commands into function calls.
        </div>

        <h3>Testing Your UCI Engine</h3>

        <p>Before loading into a GUI, test via command line:</p>

        <pre><code># Save UCI engine as uci/engine.py
# Then test manually:

$ python3 uci/engine.py
uci
<em>id name Chess_RL v0.1.0
id author Your Name
option name Engine Type type combo default minimax ...
uciok</em>

isready
<em>readyok</em>

position startpos
go depth 3
<em>info depth 3 score cp 20
bestmove e2e4</em>

quit</code></pre>

        <div class="success">
            <strong>‚úÖ If you see <code>bestmove e2e4</code> or similar, your UCI engine works!</strong>
        </div>

        <h3>Configurable Engine Options</h3>

        <p>One powerful UCI feature is configurable options. Your engine declares what settings are available, and the GUI lets users configure them:</p>

        <pre><code>def handle_setoption(self, name: str, value: str):
    """Handle engine configuration from GUI."""
    if name == "Engine Type":
        # Combo box: random, material, minimax
        self.engine_type = value

    elif name == "Search Depth":
        # Spin box: 1-6
        self.search_depth = int(value)

    elif name == "Debug":
        # Checkbox: true/false
        self.debug = (value.lower() == "true")</code></pre>

        <p>This lets users experiment with different settings:</p>
        <ul>
            <li><strong>Engine Type:</strong> Compare random vs material vs minimax</li>
            <li><strong>Search Depth:</strong> Depth 2 (fast) vs Depth 4 (strong but slower)</li>
            <li><strong>Debug:</strong> See internal thinking for troubleshooting</li>
        </ul>

        <h3>Loading into a Chess GUI</h3>

        <p>Now for the exciting part‚Äîloading your engine into a real chess GUI!</p>

        <div class="step">
            <span class="step-number">1</span>
            <strong>Download a Chess GUI</strong>
            <ul>
                <li><strong>Arena</strong> (Windows) - http://www.playwitharena.de/</li>
                <li><strong>Cute Chess</strong> (Cross-platform) - https://cutechess.com/</li>
                <li><strong>PyChess</strong> (Linux) - https://pychess.github.io/</li>
            </ul>
        </div>

        <div class="step">
            <span class="step-number">2</span>
            <strong>Configure Engine Path</strong>
            <p>In the GUI, go to Engines ‚Üí Manage ‚Üí Add New Engine</p>
            <ul>
                <li><strong>Command:</strong> <code>python3</code> or <code>python</code></li>
                <li><strong>Arguments:</strong> <code>/full/path/to/uci/engine.py</code></li>
                <li><strong>Protocol:</strong> UCI</li>
            </ul>
        </div>

        <div class="step">
            <span class="step-number">3</span>
            <strong>Start a Game!</strong>
            <p>Select "Human vs Engine" or "Engine vs Engine" and watch it play!</p>
        </div>

        <h3>Watching Your Engine Play</h3>

        <p>Once loaded, you can:</p>

        <div class="comparison">
            <div class="comparison-item">
                <h4>Play Against It</h4>
                <ul>
                    <li>Human vs Engine mode</li>
                    <li>Set difficulty via depth</li>
                    <li>See evaluation scores</li>
                    <li>Analyze your games</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>Run Tournaments</h4>
                <ul>
                    <li>Engine vs Engine matches</li>
                    <li>Multiple rounds automatically</li>
                    <li>Win/loss statistics</li>
                    <li>Compare improvements</li>
                </ul>
            </div>
        </div>

        <h3>Example: First Game Output</h3>

        <p>Here's what a typical game looks like in the GUI:</p>

        <div class="tree-diagram">
<pre>
Chess_RL (White) vs Human (Black)
Depth 3, 1300-1400 Elo estimated

1. e2e4 e7e5       (Opening: Center control)
2. g1f3 b8c6       (Development)
3. f1c4 g8f6       (Attack f7)
4. d2d3 f8c5       (Classical development)
5. b1c3 d7d6       (Solid position)
...

Result: Chess_RL wins by checkmate in 28 moves
</pre>
        </div>

        <div class="success">
            <strong>üéâ Congratulations!</strong> You've just watched your engine play real chess! This is the moment where all your hard work from Days 2-7 comes together into a playable, visible system.
        </div>

        <h3>Debugging UCI Issues</h3>

        <p>If your engine doesn't load in the GUI, enable debug mode to see what's happening:</p>

        <pre><code>def log_debug(self, message: str):
    """Log debug info that GUI can display."""
    if self.debug:
        print(f"info string DEBUG: {message}", flush=True)

# Use throughout your code:
self.log_debug(f"Position set: {self.board.fen()}")
self.log_debug(f"Searching at depth {depth}")
self.log_debug(f"Found best move: {move}")</code></pre>

        <div class="warning">
            <strong>‚ö†Ô∏è Common Issues:</strong>
            <ul>
                <li><strong>Engine doesn't respond:</strong> Make sure you're flushing stdout with <code>flush=True</code></li>
                <li><strong>Illegal moves:</strong> Check that you're parsing position correctly</li>
                <li><strong>Crashes on input:</strong> Handle exceptions in the main loop</li>
                <li><strong>Too slow:</strong> Reduce search depth or optimize search</li>
            </ul>
        </div>

        <h3>Advanced UCI Features (Optional)</h3>

        <p>Once basic UCI works, you can add more sophistication:</p>

        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Purpose</th>
                    <th>Implementation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Time Management</td>
                    <td>Respect time controls</td>
                    <td>Parse <code>go wtime btime</code></td>
                </tr>
                <tr>
                    <td>Pondering</td>
                    <td>Think on opponent's time</td>
                    <td>Search while waiting</td>
                </tr>
                <tr>
                    <td>Multi-PV</td>
                    <td>Show top N moves</td>
                    <td>Return multiple best moves</td>
                </tr>
                <tr>
                    <td>Hash Size</td>
                    <td>Configurable cache</td>
                    <td>Use for transposition tables</td>
                </tr>
            </tbody>
        </table>

        <h3>Why UCI Matters</h3>

        <div class="key-insight">
            <strong>Industry Standard:</strong> Every major chess engine (Stockfish, Komodo, Leela Chess Zero) uses UCI. By implementing it, your engine joins the ecosystem and can compete/compare with others.
        </div>

        <p>Real-world benefits:</p>
        <ul>
            <li><strong>Validation:</strong> Play real games to test your improvements</li>
            <li><strong>Measurement:</strong> Run tournaments to measure Elo accurately</li>
            <li><strong>Comparison:</strong> Compare directly against other engines</li>
            <li><strong>Analysis:</strong> Use GUIs to analyze games and find weaknesses</li>
            <li><strong>Sharing:</strong> Others can play against your engine easily</li>
        </ul>

        <h3>Testing Different Versions</h3>

        <p>One powerful use of UCI: compare engine versions to validate improvements:</p>

        <pre><code># Tournament: Before vs After Quiescence Search
Engine 1: Chess_RL_v1 (no quiescence, depth 3)
Engine 2: Chess_RL_v2 (with quiescence, depth 3)

Run 50 games...

Results:
Chess_RL_v2: 38 wins, 10 draws, 2 losses (76% score)
Performance: +180 Elo improvement

‚úÖ Quiescence search validated!</code></pre>

        <div class="success">
            <strong>‚úÖ Achievement Unlocked:</strong> You now have a complete, UCI-compliant chess engine that can:
            <ul>
                <li>Load into any UCI-compatible chess GUI</li>
                <li>Play against humans visually</li>
                <li>Compete in automated tournaments</li>
                <li>Generate PGN game records</li>
                <li>Be analyzed and improved systematically</li>
            </ul>
            <p><strong>Your engine is now "real" in every sense of the word!</strong></p>
        </div>

        <h2>üöÄ Beyond Minimax: What's Next?</h2>

        <p>You've built a tactically sound chess engine with minimax + alpha-beta + quiescence search. Here's where you can go from here:</p>

        <h3>Near-term Improvements</h3>
        <ul>
            <li><strong>Transposition Tables:</strong> Cache previously-evaluated positions to avoid re-searching the same position through different move orders (2-3x speedup!)</li>
            <li><strong>Iterative Deepening:</strong> Search depth 1, then 2, then 3, etc., using results from shallow searches to order moves in deeper searches</li>
            <li><strong>Better Move Ordering:</strong> Killer move heuristic and history heuristic (+50-100 Elo)</li>
            <li><strong>Piece-Square Tables:</strong> Pre-computed positional bonuses for better evaluation</li>
            <li><strong>Opening Book:</strong> Use pre-computed opening theory instead of searching from scratch</li>
            <li><strong>Endgame Tablebases:</strong> Use perfect endgame databases for positions with few pieces</li>
        </ul>

        <h3>Modern Approaches: ML and MCTS</h3>

        <p>Traditional engines like Stockfish use highly optimized versions of what you just built. But modern engines take a different approach:</p>

        <div class="comparison">
            <div class="comparison-item">
                <h4>Traditional (Minimax)</h4>
                <ul>
                    <li>Hand-crafted evaluation</li>
                    <li>Exhaustive search with pruning</li>
                    <li>Strong tactical play</li>
                    <li>Example: Stockfish</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>Modern (Neural Networks)</h4>
                <ul>
                    <li>Learned evaluation (no hand-crafting)</li>
                    <li>Monte Carlo Tree Search (MCTS)</li>
                    <li>Discovers novel strategies</li>
                    <li>Example: AlphaZero, Leela Chess Zero</li>
                </ul>
            </div>
        </div>

        <h3>This Project: Chess_RL</h3>

        <p>This tutorial is part of a larger project that explores <strong>reinforcement learning</strong> for chess. The minimax engine you just built serves as:</p>
        <ul>
            <li>A baseline to compare against</li>
            <li>A source of training data (play games against itself)</li>
            <li>A way to understand what a "good position" looks like before letting an RL agent learn on its own</li>
        </ul>

        <p>The next phase involves training a neural network to:</p>
        <ul>
            <li>Replace <code>evaluate()</code> with a learned value function</li>
            <li>Use MCTS guided by policy networks (which moves to explore)</li>
            <li>Learn entirely through self-play (no human knowledge needed)</li>
        </ul>

        <h2>üìñ Key Takeaways</h2>

        <div class="key-insight">
            <strong>1. Start Simple:</strong> Material counting ‚Üí Search ‚Üí Positional understanding ‚Üí Strategy. Each layer built on the previous one.
        </div>

        <div class="key-insight">
            <strong>2. Test Incrementally:</strong> After adding each component, verify it works in isolation before combining it with others.
        </div>

        <div class="key-insight">
            <strong>3. Understand Trade-offs:</strong> Search depth vs. speed, evaluation complexity vs. simplicity, tactical strength vs. strategic understanding.
        </div>

        <div class="key-insight">
            <strong>4. Optimization Matters:</strong> Alpha-beta pruning made the engine 50x faster. Move ordering made pruning 10x more effective. Small algorithmic improvements have huge impact.
        </div>

        <div class="key-insight">
            <strong>5. Domain Knowledge First:</strong> We hand-coded chess principles (center control, king safety, etc.) before considering ML. Understanding the problem deeply makes better AI.
        </div>

        <h2>üéì Further Reading</h2>

        <ul>
            <li><a href="https://www.chessprogramming.org/">Chess Programming Wiki</a> - Comprehensive resource on chess engine development</li>
            <li><a href="https://lichess.org/blog/WFQ0pSQAACMA8e9D/hello-lichess-bot-api">Lichess Bot API</a> - Deploy your engine to play online</li>
            <li><strong>AlphaZero Paper:</strong> "Mastering Chess and Shogi by Self-Play with a General Reinforcement Learning Algorithm"</li>
            <li><strong>Stockfish Source Code:</strong> See how the world's strongest traditional engine works</li>
        </ul>

        <h2>üíª Try It Yourself</h2>

        <p>All the code from this tutorial is available in this repository:</p>

        <pre><code># Clone the repository
git clone https://github.com/yourusername/Chess_RL.git

# Install dependencies
pip install python-chess

# Run the engine
python search/minimax.py

# Play against it
python run_uci_engine.sh</code></pre>

        <div class="success">
            <strong>üèÜ Challenge:</strong> Extend this engine with your own ideas! Try adding:
            <ul>
                <li>Piece-square tables (positional bonuses for specific squares)</li>
                <li>Tempo evaluation (having the initiative)</li>
                <li>Threat detection (what's my opponent attacking?)</li>
                <li>Better endgame evaluation (king activity in endgames)</li>
            </ul>
        </div>

        <hr style="margin: 40px 0;">

        <p style="text-align: center; color: #7f8c8d; font-size: 0.9em;">
            <em>This tutorial documents the actual development process of the Chess_RL project.<br>
            Built incrementally, tested thoroughly, and documented for learners.<br>
            From zero to a complete, playable chess engine in 8 days of development.</em>
        </p>

        <p style="text-align: center; margin-top: 20px;">
            <strong>Ready to build something amazing? Start with Day 2 and work your way up! üöÄ</strong>
        </p>
    </div>
</body>
</html>
